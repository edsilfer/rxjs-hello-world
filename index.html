<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="showcase.css">
  <link rel="stylesheet" href="blockquote.css">
  <title>RxJS</title>
  <link rel="shortcut icon" type="image/png" href="favicon.png" />
</head>

<body>
  <header>
    <div class="header-content">
      <img src="https://cdn-images-1.medium.com/max/1600/1*sXrpvkWUPm1K9zGKhI3MlA.png" width="50" height="50" />
      <h1>Sample RxJS with Github API</h1>
    </div>
  </header>
  <main>
    <section class="intro">
      <blockquote>
        <p>RxJS is a library for <a href="https://en.wikipedia.org/wiki/Reactive_programming">reactive programming</a> using Observables, to make it easier to compose asynchronous or callback-based code. This project is a rewrite of Reactive-Extensions/RxJS with better performance, better modularity, better debuggable call stacks, while staying mostly backwards compatible, with some breaking changes that reduce the API surface</p>
        <p class="author"><i><a href="https://rxjs-dev.firebaseapp.com/"><i>Check project page.</i></a></i></p>
      </blockquote>
      <h2>Purpose</h2>
      <p>The goal of this post is to describe the learnings involved in the process of creating a widget using <a href="https://rxjs-dev.firebaseapp.com/">RxJS</a>. I've decided to make this example in order to increase my knowledge of <a href="https://en.wikipedia.org/wiki/Reactive_programming">reactive programming</a>. Even though my current area of acting is Java, the methods and strategies here applied can be easily migrated to any reactive implementation, therefore I encourage you to continue reading this post and try these exercises yourself.</p>
      <h2>Goals</h2>
      <p>The proposed exercise is based on post <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">The introduction to Reactive Programming you've been missing</a> written by <a href="https://twitter.com/andrestaltz">Andre Staltz</a>. The idea is to build a Twitter like widget that suggests users to follow. As Twitter closed its API to unauthorized public, <a href="https://developer.github.com/v3/">GitHub API</a> will be used in the place. The requirements are:</p>
      <ul>
        <li>There must be a constant in the code that allows setting the number of accounts to suggest;</li>
        <li>Each suggestion must display a "remove" button that the user can press if he doesn't like the suggestion;</li>
        <li>Whenever user clicks "remove", the suggestion will be removed from the list and a new one will take its place;</li>
        <li>A refresh button must be provided in order to drop all current suggestions and provide new ones;</li>
        <li>As GitHub API returns 100 users per request, no call should be made until the first 100 users have been all suggested/consumed;</li>
      </ul>
    </section>
    
    <section class="showcase">
      <h2>Showcase</h2>
      <div class="container">
        <ul id="users"></ul>
        <button id="refresh" type="button" class="btn btn-primary refresh-button">Refresh</button>
      </div>
      <p class="subtitle">Sample widget build as result of this exercise</p>
    </section>
    
    <section class="development">
      <h2>Development</h2>
      <p>The step-by-step development can be found on <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">The introduction to Reactive Programming you've been missing</a>. This post will focus on a few particularities that I've found while implementing it, mostly two:</p>
      <ul>
        <li>How to handle the creation of suggestions without <i>breaking the pipe</i>?</li>
        <li>How to add a new suggestion after removing an old one?</li>
      </ul>
      <p>Before I explain how I've dealt with these problems, let's make a quick review implementation. We have four streams composing this project:</p>
      <ul>
        <li><b>request:</b> performs a request to GitHub API and emits an Array of users;</li>
        <li><b>refresh:</b> combination of request and "refresh clicked" streams;</li>
        <li><b>random user:</b> a combination of user removed and request streams;</li>
        <li><b>user removed:</b> stream of values indicating that a suggestion was removed;</li>
      </ul>
      <p><b>NOTE: </b>The final consumer for all of the streams is responsible for:</p>
      <ul>
        <li>limit the amount of suggestions to process;</li>
        <li>create the suggestion item;</li>
        <li>add the new item to the list;</li>
        <li>subscribe for the remove event;</li>
        <li>issue a new item on user removed stream;</li>
      </ul>
      <h3>Creating suggestiong without breaking the pipe</h3>
      <p>In order to resolve this problem, I've converted the pipeline into a stream of clicks from the corresponding remove button - <a href="https://www.learnrxjs.io/operators/transformation/mergemap.html">mergeMap</a> is the operator for that - right after adding a suggestion to the list. To handle the event selector, a bit of string processing was done: we add the name of the user, which is unique, as the id of the li and the button, that way we can handle the removal of it later on.</p>
      
      <h3>Adding new suggestions</h3>
      <p>For the second problem we have created the user removed stream, emitting a new value into it right after removing a list item. A key operator was used in order to keep the system stateless: <a href="https://www.learnrxjs.io/operators/combination/combinelatest.html">combineLatest</a>. The combineLatest operator buffers the latest values emitted by both streams, allowing us to specify a callback to determine which value to emit next.</p>
      <p>With the elements aforementioned, we combined the request with refresh and user removed streams in order to reuse the results of the first call to GitHub API. There is a trick part on doing that though, we need to specify the request stream to be multicasting, otherwise the stream Observable will remain cold and the stream will be invoked at every time it is passed to combine latest - this part was kindly explained to my alter ego by user <a href="https://stackoverflow.com/users/2521865/paulpdaniels">@paulpdaniels</a> in this <a href="https://stackoverflow.com/questions/52718262/why-is-initial-stream-being-triggered-again-after-combinelatest-and-merge-in-thi/52723645#52723645">StackOverflow question.</a></p>
    </section>
  </main>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/rxjs/5.4.3/Rx.js"></script>
  <script src="utils.js"></script>
  <script src="main.js"></script>
</body>

</html>